<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo wjq</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-05T13:44:15.905Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wjq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多个属性运动框架。</title>
    <link href="http://yoursite.com/2017/05/05/%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7%E8%BF%90%E5%8A%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/05/05/多个属性运动框架/</id>
    <published>2017-05-05T13:19:05.258Z</published>
    <updated>2017-05-05T13:44:15.905Z</updated>
    
    <content type="html"><![CDATA[<p>核心代码：</p>
<pre><code>// 多个属性运动框架  添加回调函数
function animate(obj,json,fn) {  // 给谁    json
    clearInterval(obj.timer);
    obj.timer = setInterval(function() {
        var flag = true;  // 用来判断是否停止定时器   一定写到遍历的外面
        for(var attr in json){   // attr  属性     json[attr]  值
            //开始遍历 json
            // 计算步长    用 target 位置 减去当前的位置  除以 10
           // console.log(attr);
            var current = parseInt(getStyle(obj,attr));  // 数值
           // console.log(current);
             // 目标位置就是  属性值
            var step = ( json[attr] - current) / 10;  // 步长  用目标位置 - 现在的位置 / 10
            step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
            obj.style[attr] = current  + step + &quot;px&quot; ;
            console.log(current);
            if(current != json[attr])  // 只要其中一个不满足条件 就不应该停止定时器  这句一定遍历里面
            {
                flag =  false;
            }
        }
        if(flag)  // 用于判断定时器的条件
        {
            clearInterval(obj.timer);
            //alert(&quot;ok了&quot;);
            if(fn)   // 很简单   当定时器停止了。 动画就结束了  如果有回调，就应该执行回调
            {
                fn(); // 函数名 +  （）  调用函数  执行函数
            }
        }
    },30)
}

function getStyle(obj,attr) {  //  谁的      那个属性
    if(obj.currentStyle)  // ie 等
    {
        return obj.currentStyle[attr];  // 返回传递过来的某个属性
    }
    else
    {
        return window.getComputedStyle(obj,null)[attr];  // w3c 浏览器
    }
}
</code></pre><p>完整代码:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;style&gt;
    div {
        width: 100px;
        height: 100px;
        background-color: pink;
        position: absolute;
        left: 0;
        top: 50px;
        border-radius: 50%;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button id=&quot;btn200&quot;&gt;200&lt;/button&gt;
&lt;button id=&quot;btn400&quot;&gt;400&lt;/button&gt;
&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
    var btn200 = document.getElementById(&quot;btn200&quot;);
    var btn400 = document.getElementById(&quot;btn400&quot;);
    var box = document.getElementById(&quot;box&quot;);
    btn200.onclick = function() {
        animate(box,{width: 200, top: 800,left: 200},function(){alert(&quot;我来了&quot;)});
    }
    btn400.onclick = function() {
        animate(box,{top:500});
    }
    // 多个属性运动框架  添加回调函数
    function animate(obj,json,fn) {  // 给谁    json
        clearInterval(obj.timer);
        obj.timer = setInterval(function() {
            var flag = true;  // 用来判断是否停止定时器   一定写到遍历的外面
            for(var attr in json){   // attr  属性     json[attr]  值
                //开始遍历 json
                // 计算步长    用 target 位置 减去当前的位置  除以 10
               // console.log(attr);
                var current = parseInt(getStyle(obj,attr));  // 数值
               // console.log(current);
                 // 目标位置就是  属性值
                var step = ( json[attr] - current) / 10;  // 步长  用目标位置 - 现在的位置 / 10
                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
                obj.style[attr] = current  + step + &quot;px&quot; ;
                console.log(current);
                if(current != json[attr])  // 只要其中一个不满足条件 就不应该停止定时器  这句一定遍历里面
                {
                    flag =  false;
                }
            }
            if(flag)  // 用于判断定时器的条件
            {
                clearInterval(obj.timer);
                //alert(&quot;ok了&quot;);
                if(fn)   // 很简单   当定时器停止了。 动画就结束了  如果有回调，就应该执行回调
                {
                    fn(); // 函数名 +  （）  调用函数  执行函数
                }
            }
        },30)
    }
    function getStyle(obj,attr) {  //  谁的      那个属性
        if(obj.currentStyle)  // ie 等
        {
            return obj.currentStyle[attr];  // 返回传递过来的某个属性
        }
        else
        {
            return window.getComputedStyle(obj,null)[attr];  // w3c 浏览器
        }
    }
&lt;/script&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 多个属性运动框架  添加回调函数
function animate(obj,json,fn) {  // 给谁    json
    clearInterval(obj.timer);
    obj.timer = set
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css之缓动动画原理</title>
    <link href="http://yoursite.com/2017/05/05/css_%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/05/05/css_缓动动画/</id>
    <published>2017-05-05T08:08:47.941Z</published>
    <updated>2017-05-05T08:14:23.276Z</updated>
    
    <content type="html"><![CDATA[<p>核心代码：</p>
<pre><code> btn.onclick = function() {
     timer = setInterval(function() {
         // 盒子本身的位置  +  步长 (不断变化的)
         //target指的是目标位置，step在慢慢变小
         var step = (target - box.offsetLeft) / 10;   // 步长
         console.log(step);
         step =  step &gt; 0 ? Math.ceil(step) : Math.floor(step);  // 步长取整
         box.style.left = box.offsetLeft + step + &quot;px&quot;;
         if(box.offsetLeft == target) // 判断结束条件
         {
             clearInterval(timer);
         }
     },30)

}
</code></pre><p>完整代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        div {
            width: 100px;
            height: 100px;
            background-color: pink;
            position: absolute;
            left: 0px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button id=&quot;btn&quot;&gt;开始&lt;/button&gt;
&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
    var btn = document.getElementById(&quot;btn&quot;);
    var box = document.getElementById(&quot;box&quot;);
    var target = 400;
    var timer = null;
    btn.onclick = function() {
         timer = setInterval(function() {
             // 盒子本身的位置  +  步长 (不断变化的)
             var step = (target - box.offsetLeft) / 10;   // 步长
             console.log(step);
             step =  step &gt; 0 ? Math.ceil(step) : Math.floor(step);  // 步长取整
             box.style.left = box.offsetLeft + step + &quot;px&quot;;
             if(box.offsetLeft == target) // 判断结束条件
             {
                 clearInterval(timer);
                 alert(&quot;到目标了&quot;)
             }
         },30)

    }
&lt;/script&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; btn.onclick = function() {
     timer = setInterval(function() {
         // 盒子本身的位置  +  步长 (不断变化的)
         //targ
    
    </summary>
    
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>获取用户选择的内容</title>
    <link href="http://yoursite.com/2017/05/04/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E9%80%89%E6%8B%A9%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2017/05/04/获取用户选择的内容/</id>
    <published>2017-05-04T12:39:54.667Z</published>
    <updated>2017-05-04T12:42:41.991Z</updated>
    
    <content type="html"><![CDATA[<pre><code>if(window.getSelection)  // 获取我们选中的文字,w3c写法
{
    txt = window.getSelection().toString();   // 转换为字符串
}
else
{
    txt = document.selection.createRange().text;   // ie 的写法
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;if(window.getSelection)  // 获取我们选中的文字,w3c写法
{
    txt = window.getSelection().toString();   // 转换为字符串
}
else
{
    txt = document
    
    </summary>
    
    
      <category term="getSelection，selection" scheme="http://yoursite.com/tags/getSelection%EF%BC%8Cselection/"/>
    
  </entry>
  
  <entry>
    <title>阻止事件冒泡</title>
    <link href="http://yoursite.com/2017/05/04/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1/"/>
    <id>http://yoursite.com/2017/05/04/阻止冒泡/</id>
    <published>2017-05-04T12:10:16.397Z</published>
    <updated>2017-05-04T12:17:23.751Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="描述：事件冒泡：一个div绑定了点击事件，div的父级是body，body的父级是html，所以点击div相当于点击了body，点击了html。如果body或者html也有点击事件，就会出现异常。"><a href="#描述：事件冒泡：一个div绑定了点击事件，div的父级是body，body的父级是html，所以点击div相当于点击了body，点击了html。如果body或者html也有点击事件，就会出现异常。" class="headerlink" title="描述：事件冒泡：一个div绑定了点击事件，div的父级是body，body的父级是html，所以点击div相当于点击了body，点击了html。如果body或者html也有点击事件，就会出现异常。"></a>描述：事件冒泡：一个div绑定了点击事件，div的父级是body，body的父级是html，所以点击div相当于点击了body，点击了html。如果body或者html也有点击事件，就会出现异常。</h3><p>阻止冒泡的方法：</p>
<pre><code>var event = event || window.event;        //window.evetn兼容ie
if(event &amp;&amp; event.stopPropagation)        //一般浏览器
{
    event.stopPropagation();
}
else                                    //ie浏览器
{
    event.cancelBubble = true;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;描述：事件冒泡：一个div绑定了点击事件，div的父级是body，body的父级是html，所以点击div相当于点击了body，点击了html。如果body或者html也有点击事件，就会出现异常。&quot;&gt;&lt;a href=&quot;#描述：事件冒泡：一个div绑定了点
    
    </summary>
    
    
      <category term="冒泡" scheme="http://yoursite.com/tags/%E5%86%92%E6%B3%A1/"/>
    
  </entry>
  
  <entry>
    <title>css选择器优先级</title>
    <link href="http://yoursite.com/2017/04/28/css/"/>
    <id>http://yoursite.com/2017/04/28/css/</id>
    <published>2017-04-28T11:55:00.000Z</published>
    <updated>2017-04-28T12:01:42.277Z</updated>
    
    <content type="html"><![CDATA[<p>1、多重样式（Multiple Styles）：如果外部样式、内部样式和内联样式同时应用于同一个元素，就是使多重样式的情况。</p>
<p>一般情况下，优先级如下：</p>
<pre><code>（外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style
</code></pre><p>有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。</p>
<h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><ol>
<li>内联样式表的权值最高 1000</li>
<li>ID 选择器的权值为 100</li>
<li>Class 类选择器的权值为 10</li>
<li>HTML 标签选择器的权值为 1</li>
</ol>
<p>CSS 优先级法则：</p>
<p>A  选择器都有一个权值，权值越大越优先</p>
<p>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置</p>
<p>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式</p>
<p>D  继承的CSS 样式不如后来指定的CSS 样式</p>
<p>E  在同一组属性设置中标有“!important”规则的优先级最大</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、多重样式（Multiple Styles）：如果外部样式、内部样式和内联样式同时应用于同一个元素，就是使多重样式的情况。&lt;/p&gt;
&lt;p&gt;一般情况下，优先级如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;（外部样式）External style sheet &amp;lt;（内部样式）In
    
    </summary>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>封装client，scroll。</title>
    <link href="http://yoursite.com/2017/04/08/1/"/>
    <id>http://yoursite.com/2017/04/08/1/</id>
    <published>2017-04-08T06:02:38.000Z</published>
    <updated>2017-05-04T09:39:00.781Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="title-封装client，scroll。"><a href="#title-封装client，scroll。" class="headerlink" title="title: 封装client，scroll。"></a>title: 封装client，scroll。</h2><p>##client函数封装</p>
<h3 id="创建一个js文件，里面是client的封装函数"><a href="#创建一个js文件，里面是client的封装函数" class="headerlink" title="创建一个js文件，里面是client的封装函数"></a>创建一个js文件，里面是client的封装函数</h3><h3 id="myclient-js"><a href="#myclient-js" class="headerlink" title="myclient.js"></a>myclient.js</h3><pre><code>function client() {
    if(window.innerWidth != null)  // ie9 +  最新浏览器
    {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        }
    }
    else if(document.compatMode === &quot;CSS1Compat&quot;)  // 标准浏览器
    {
        return {
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight
        }
    }
    return {   // 怪异浏览器
        width: document.body.clientWidth,
        height: document.body.clientHeight

    }
}
</code></pre><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>引入myclient.js后直接使用，如下：</p>
<pre><code>document.write(client().width);
</code></pre><p>##scroll封装</p>
<h3 id="创建一个js文件myscroll-js"><a href="#创建一个js文件myscroll-js" class="headerlink" title="创建一个js文件myscroll.js"></a>创建一个js文件myscroll.js</h3><h3 id="myscroll-js"><a href="#myscroll-js" class="headerlink" title="myscroll.js"></a>myscroll.js</h3><pre><code>function scroll() {
    if(window.pageYOffset != null)  //  ie9+ 和其他浏览器
    {
        return {
            left: window.pageXOffset,
            top: window.pageYOffset
        }
    }
    else if(document.compatMode == &quot;CSS1Compat&quot;)  // 声明的了 DTD
    // 检测是不是怪异模式的浏览器 -- 就是没有 声明&lt;!DOCTYPE html&gt;
    {
        return {
            left: document.documentElement.scrollLeft,
            top: document.documentElement.scrollTop
        }
    }
    return { //  剩下的肯定是怪异模式的
        left: document.body.scrollLeft,
        top: document.body.scrollTop
    }
}
</code></pre><h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><p>引入myscroll.js后直接使用，例如：</p>
<pre><code>document.title = scroll().top;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;title-封装client，scroll。&quot;&gt;&lt;a href=&quot;#title-封装client，scroll。&quot; class=&quot;headerlink&quot; title=&quot;title: 封装client，scroll。&quot;&gt;&lt;/a&gt;title: 封装clien
    
    </summary>
    
    
      <category term="client , scroll" scheme="http://yoursite.com/tags/client-scroll/"/>
    
  </entry>
  
  <entry>
    <title>封装client，scroll。</title>
    <link href="http://yoursite.com/2017/04/08/client_scroll/"/>
    <id>http://yoursite.com/2017/04/08/client_scroll/</id>
    <published>2017-04-08T06:02:38.000Z</published>
    <updated>2017-05-04T09:56:22.565Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="title-封装client，scroll。"><a href="#title-封装client，scroll。" class="headerlink" title="title: 封装client，scroll。"></a>title: 封装client，scroll。</h2><p>##client函数封装</p>
<h3 id="创建一个js文件，里面是client的封装函数。client：检测屏幕的宽度（可视区域的大小）"><a href="#创建一个js文件，里面是client的封装函数。client：检测屏幕的宽度（可视区域的大小）" class="headerlink" title="创建一个js文件，里面是client的封装函数。client：检测屏幕的宽度（可视区域的大小）"></a>创建一个js文件，里面是client的封装函数。client：检测屏幕的宽度（可视区域的大小）</h3><h3 id="myclient-js"><a href="#myclient-js" class="headerlink" title="myclient.js"></a>myclient.js</h3><pre><code>function client() {
    if(window.innerWidth != null)  // ie9 +  最新浏览器
    {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        }
    }
    else if(document.compatMode === &quot;CSS1Compat&quot;)  // 标准浏览器
    {
        return {
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight
        }
    }
    return {   // 怪异浏览器
        width: document.body.clientWidth,
        height: document.body.clientHeight

    }
}
</code></pre><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>引入myclient.js后直接使用，如下：</p>
<pre><code>document.write(client().width);
</code></pre><p>##scroll封装</p>
<h3 id="创建一个js文件myscroll-js，scroll：屏幕滚动的区域，已经看不到的一部分，超出屏幕最上方或者最左边的部分"><a href="#创建一个js文件myscroll-js，scroll：屏幕滚动的区域，已经看不到的一部分，超出屏幕最上方或者最左边的部分" class="headerlink" title="创建一个js文件myscroll.js，scroll：屏幕滚动的区域，已经看不到的一部分，超出屏幕最上方或者最左边的部分"></a>创建一个js文件myscroll.js，scroll：屏幕滚动的区域，已经看不到的一部分，超出屏幕最上方或者最左边的部分</h3><h3 id="myscroll-js"><a href="#myscroll-js" class="headerlink" title="myscroll.js"></a>myscroll.js</h3><pre><code>function scroll() {
    if(window.pageYOffset != null)  //  ie9+ 和其他浏览器
    {
        return {
            left: window.pageXOffset,
            top: window.pageYOffset
        }
    }
    else if(document.compatMode == &quot;CSS1Compat&quot;)  // 声明的了 DTD
    // 检测是不是怪异模式的浏览器 -- 就是没有 声明&lt;!DOCTYPE html&gt;
    {
        return {
            left: document.documentElement.scrollLeft,
            top: document.documentElement.scrollTop
        }
    }
    return { //  剩下的肯定是怪异模式的
        left: document.body.scrollLeft,
        top: document.body.scrollTop
    }
}
</code></pre><h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><p>引入myscroll.js后直接使用，例如：</p>
<pre><code>document.title = scroll().top;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;title-封装client，scroll。&quot;&gt;&lt;a href=&quot;#title-封装client，scroll。&quot; class=&quot;headerlink&quot; title=&quot;title: 封装client，scroll。&quot;&gt;&lt;/a&gt;title: 封装clien
    
    </summary>
    
    
      <category term="client , scroll" scheme="http://yoursite.com/tags/client-scroll/"/>
    
  </entry>
  
</feed>
